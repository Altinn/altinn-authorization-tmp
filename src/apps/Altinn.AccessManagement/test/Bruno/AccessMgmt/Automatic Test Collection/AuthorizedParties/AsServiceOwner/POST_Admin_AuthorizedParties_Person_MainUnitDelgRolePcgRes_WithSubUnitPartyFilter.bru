meta {
  name: POST_Admin_AuthorizedParties_Person_MainUnitDelgRolePcgRes_WithSubUnitPartyFilter
  type: http
  seq: 10
}

post {
  url: {{baseUrl}}/accessmanagement/api/v1/resourceowner/authorizedparties?includeAltinn2=true&includeAltinn3=true&includeAccessPackages=true
  body: json
  auth: inherit
}

params:query {
  includeAltinn2: true
  includeAltinn3: true
  includeAccessPackages: true
}

headers {
  Content-Type: application/json
  Accept: application/json
}

body:json {
  {
    "type": "urn:altinn:person:identifier-no",
    "value": "{{personId}}",
    "partyFilter": [
      {
        "type": "urn:altinn:party:uuid",
        "value": "{{filterSubUnitParty}}"
      }
    ]
  }
}

script:pre-request {
  const sharedtestdata = require(`./Testdata/sharedtestdata.json`);
  const testdata = require(`./Testdata/authorizedparties/${bru.getEnvVar("tokenEnv")}.json`);
  
  bru.setVar("requestName", "POST_Admin_AuthorizedParties_Person_MainUnitDelgRolePcgRes_WithSubUnitPartyFilter");
  bru.setVar("personId", testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.dagligleder.pid);
  bru.setVar("filterSubUnitParty", testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.client_rightholderOrg2.subunit.partyUuid);
  
  var getTokenParameters = {
    auth_org: sharedtestdata.serviceOwners.digdir.org,
    auth_orgNo: sharedtestdata.serviceOwners.digdir.orgno,
    auth_tokenType: sharedtestdata.authTokenType.enterprise,
    auth_scopes: sharedtestdata.auth_scopes.authorizedPartiesAdmin
  }
  
  const token = await testTokenGenerator.getToken(getTokenParameters);
  bru.setVar("bearerToken", token);
}

tests {
  const testdata = require(`./Testdata/authorizedparties/${bru.getEnvVar("tokenEnv")}.json`);
  const body = res.getBody();
  const requestName = bru.getVar("requestName");
  
  const expectedMainUnit = testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.client_rightholderOrg2;
  const expectedSubUnit = testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.client_rightholderOrg2.subunit;
  
  test(requestName + "|HttpStatus.OK", function() {
    expect(res.status).to.equal(200);
  });
  
  test(requestName + "|Verify all expected parties exists with expected access", function() {
    const allParties = body.flatMap(party => [party, ...(party.subunits || [])]);
    const actualMainUnit = allParties.find(party => party.partyUuid === expectedMainUnit.partyUuid);
    const actualSubUnit = allParties.find(party => party.partyUuid === expectedMainUnit.subunit.partyUuid);
  
    assert.exists(actualMainUnit, 'Expected MainUnit Party: '+expectedMainUnit.name+' to exist');
    assert.exists(actualSubUnit, 'Expected SubUnit Party: '+expectedMainUnit.subunit.name+' to exist');
    expect(allParties.length, `Result should only contain the parties filtered`).to.equal(2);
    
    const expectedRolesMainUnit = [
      expectedMainUnit.roleDelegatedToPerson,
      expectedMainUnit.roleDelegatedToKeyRoleUnit
    ];
    const expectedRolesSubUnit = [
      expectedMainUnit.roleDelegatedToPerson,
      expectedMainUnit.roleDelegatedToKeyRoleUnit,
      expectedMainUnit.subunit.roleDelegatedToPerson,
      expectedMainUnit.subunit.roleDelegatedToKeyRoleUnit
    ];
    
    assert.includeMembers(actualMainUnit.authorizedRoles, expectedRolesMainUnit);
    assert.includeMembers(actualSubUnit.authorizedRoles, expectedRolesSubUnit);
    
    const expectedPackagesMainUnit = [
      expectedMainUnit.directPackageToDelegate,
      expectedMainUnit.directPackageToDelegate2,
      expectedMainUnit.packageDelegatedToPerson
    ];
    const expectedPackagesSubUnit = [
      expectedMainUnit.directPackageToDelegate,
      expectedMainUnit.directPackageToDelegate2,
      expectedMainUnit.packageDelegatedToPerson,
      expectedMainUnit.subunit.packageDelegatedToPerson,
      expectedMainUnit.subunit.packageDelegatedToKeyRoleUnit
    ];
    
    assert.includeMembers(actualMainUnit.authorizedAccessPackages, expectedPackagesMainUnit);
    assert.includeMembers(actualSubUnit.authorizedAccessPackages, expectedPackagesSubUnit);
    
    const expectedResourcesMainUnit = [
      expectedMainUnit.resourceIdDelegatedToPerson,
      expectedMainUnit.resourceIdDelegatedToKeyRoleUnit,
      expectedMainUnit.appIdDelegatedToPerson,
      expectedMainUnit.appIdDelegatedToKeyRoleUnit
    ];
    const expectedResourcesSubUnit = [
      expectedMainUnit.resourceIdDelegatedToPerson,
      expectedMainUnit.resourceIdDelegatedToKeyRoleUnit,
      expectedMainUnit.appIdDelegatedToPerson,
      expectedMainUnit.appIdDelegatedToKeyRoleUnit,
      expectedMainUnit.subunit.resourceIdDelegatedToPerson,
      expectedMainUnit.subunit.resourceIdDelegatedToKeyRoleUnit
    ];
    
    assert.includeMembers(actualMainUnit.authorizedResources, expectedResourcesMainUnit);
    assert.includeMembers(actualSubUnit.authorizedResources, expectedResourcesSubUnit);
    
    const expectedInstanceResourceId = testdata.resources.appInstanceDelegation.resourceId;
    const expectedInstancesMainUnit = [
      expectedMainUnit.instanceIdDelegatedToPerson,
      expectedMainUnit.instanceIdDelegatedToKeyRoleUnit
    ];
    const expectedInstancesSubUnit = [
      expectedMainUnit.subunit.instanceIdDelegatedToPerson,
      expectedMainUnit.subunit.instanceIdDelegatedToKeyRoleUnit
    ];
    
    assertInstances(actualMainUnit.authorizedInstances, expectedInstancesMainUnit, expectedInstanceResourceId);
    assertInstances(actualSubUnit.authorizedInstances, expectedInstancesSubUnit, expectedInstanceResourceId);
  });
  
  test(requestName + "|Inherits all mainunit accesses on subunits", function() {  
    // Test that all authorized rights on main units also exists on all subunits
    body.forEach((party, partyIndex) => {
      if (party.subunits && party.subunits.length > 0) {
        party.subunits.forEach((subunit, subunitIndex) => {
          try {
            assert.includeMembers(
              subunit.authorizedAccessPackages,
              party.authorizedAccessPackages,
              `Subunit ${subunitIndex} of party ${partyIndex} does not include all authorizedAccessPackages`
            );
  
            assert.includeMembers(
              subunit.authorizedResources,
              party.authorizedResources,
              `Subunit ${subunitIndex} of party ${partyIndex} does not include all authorizedResources`
            );
  
            assert.includeMembers(
              subunit.authorizedRoles,
              party.authorizedRoles,
              `Subunit ${subunitIndex} of party ${partyIndex} does not include all authorizedRoles`
            );
          } catch (error) {
            console.error(error.message);
            throw error; // Re-throw to make sure Bruno registers the test as failed
          }
        });
      }
    });
    
  });
  
  test(requestName + "|Mainunit AuthorizedInstances not inheirited to subunits", function() {  
    // Test that any authorized instances on main units does not exist on any subunits
    body.forEach((party, partyIndex) => {
      const parentInstances = party.authorizedInstances || [];
  
      if (party.subunits && party.subunits.length > 0 && parentInstances.length > 0) {
        party.subunits.forEach((subunit, subunitIndex) => {
          const subunitInstances = subunit.authorizedInstances || [];
  
          const overlappingInstances = parentInstances.filter(instance =>
            subunitInstances.includes(instance)
          );
  
          try {
            assert.strictEqual(
              overlappingInstances.length,
              0,
              `Subunit ${subunitIndex} of party ${partyIndex} contains one or more parent authorizedInstances: ${overlappingInstances.join(', ')}`
            );
          } catch (error) {
            console.error(error.message);
            throw error;
          }
        });
      }
    });
  
  });
  
  test(requestName + "|Check for duplicate parties in the response", function() {  
    // Step 1: Collect all partyUuids
    const allPartyUuids = [];
  
    body.forEach(party => {
      allPartyUuids.push(party.partyUuid);
      if (party.subunits && party.subunits.length > 0) {
        party.subunits.forEach(subunit => {
          allPartyUuids.push(subunit.partyUuid);
        });
      }
    });
  
    // Step 2: Find duplicates
    const uuidCount = {};
    const duplicates = [];
  
    allPartyUuids.forEach(uuid => {
      uuidCount[uuid] = (uuidCount[uuid] || 0) + 1;
      if (uuidCount[uuid] === 2) {
        duplicates.push(uuid); // only push once when it becomes a duplicate
      }
    });
  
    // Step 3: Assert no duplicates
    expect(duplicates.length, `Duplicate partyUuid(s) found: ${duplicates.join(', ')}`).to.equal(0);
  
  });
  
  // Helper to assert instances against expected IDs (order-agnostic)
  function assertInstances(actualInstances, expectedInstanceIds, expectedResourceId) {
    expect(actualInstances, 'authorizedInstances must be an array').to.be.an('array');
    expect(actualInstances.length, 'unexpected number of instances').to.equal(expectedInstanceIds.length);
  
    // Validate all have expected resourceId
    actualInstances.forEach((inst, idx) => {
      expect(inst, `instance object at index ${idx} must be an object`).to.be.an('object');
      expect(inst).to.have.property('resourceId', expectedResourceId);
      expect(inst).to.have.property('instanceId').that.is.a('string').and.is.not.empty;
    });
  
    // Compare sets of instanceIds (order-agnostic)
    const actualIds = actualInstances.map(i => i.instanceId).sort();
    const expectedIdsSorted = [...expectedInstanceIds].sort();
    expect(actualIds).to.deep.equal(expectedIdsSorted);
  
    // Ensure uniqueness
    const uniqueCount = new Set(actualIds).size;
    expect(uniqueCount, 'duplicate instanceIds found').to.equal(actualIds.length);
  }
  
}
