meta {
  name: GET_AuthorizedParties_RightholderWithPackages_WithoutAccessInfo
  type: http
  seq: 9
}

get {
  url: {{baseUrl}}/accessmanagement/api/v1/authorizedparties?includeAltinn2=true&includeAltinn3=true&includeRoles=false&includeAccessPackages=false&includeResources=false&includeInstances=false
  body: json
  auth: inherit
}

params:query {
  includeAltinn2: true
  includeAltinn3: true
  includeRoles: false
  includeAccessPackages: false
  includeResources: false
  includeInstances: false
}

headers {
  Content-Type: application/json
  Accept: application/json
}

script:pre-request {
  
  const sharedtestdata = require(`./testdata/sharedtestdata.js`);
  const testdata = require(`./test/AuthorizedParties/testdata/${bru.getEnvVar("tokenEnv")}.js`);
  
  bru.setVar("requestName", "GET_AuthorizedParties_RightholderWithPackages_WithoutAccessInfo");
  
  var getTokenParameters = {
    auth_userId: testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.employee_rightholderWithPackages.userId,
    auth_partyId: testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.employee_rightholderWithPackages.partyId,
    auth_partyUuid: testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.employee_rightholderWithPackages.partyUuid,
    auth_ssn: testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.employee_rightholderWithPackages.pid,
    auth_tokenType: sharedtestdata.authTokenType.personal,
    auth_scopes: sharedtestdata.auth_scopes.portalEnduser
  }
  
  
const testTokenGenerator = require(`./TestToolsTokenGenerator.js`);
const token = await testTokenGenerator.getToken(getTokenParameters);
  bru.setVar("bearerToken", token);
}

tests {
  const testdata = require(`./test/AuthorizedParties/testdata/${bru.getEnvVar("tokenEnv")}.js`);
  const body = res.getBody();
  const requestName = bru.getVar("requestName");
  
  test(requestName + "|HttpStatus.OK", function() {
    expect(res.status).to.equal(200);
  });
  
  test(requestName + "|Verify all expected parties exists but have empty authorization info", function() {  
    // Loop through each item in the response
    body.forEach(item => {
      // Assert arrays are empty
      expect(item.authorizedAccessPackages).to.be.empty;
      expect(item.authorizedRoles).to.be.empty;
      expect(item.authorizedResources).to.be.empty;
      expect(item.authorizedInstances).to.be.empty;
  
      // If there are subunits, check them too
      if (item.subunits && item.subunits.length > 0) {
        item.subunits.forEach(subunit => {
          expect(subunit.authorizedAccessPackages).to.be.empty;
          expect(subunit.authorizedRoles).to.be.empty;
          expect(subunit.authorizedResources).to.be.empty;
          expect(subunit.authorizedInstances).to.be.empty;
        });
      }
    });
    
    const allParties = body.flatMap(party => [party, ...(party.subunits || [])]);
    const targetParty = allParties.find(party => party.partyUuid === testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.partyUuid);
    const targetSubUnit = allParties.find(party => party.partyUuid === testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.subunit.partyUuid);
  
    assert.exists(targetParty, 'Expected MainUnit Party: '+testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.name+' to exist');
    assert.exists(targetSubUnit, 'Expected SubUnit Party: '+testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.subunit.name+' to exist');
    assert.isNotOk(targetParty.onlyHierarchyElementWithNoAccess, 'Expected MainUnit '+testdata.REGN_ULASTELIG_RETTFERDIG_TIGER.name+' to have onlyHierarchyElementWithNoAccess false');
  
  });
  
  test(requestName + "|Check for duplicate parties in the response", function() {  
    // Step 1: Collect all partyUuids
    const allPartyUuids = [];
  
    body.forEach(party => {
      allPartyUuids.push(party.partyUuid);
      if (party.subunits && party.subunits.length > 0) {
        party.subunits.forEach(subunit => {
          allPartyUuids.push(subunit.partyUuid);
        });
      }
    });
  
    // Step 2: Find duplicates
    const uuidCount = {};
    const duplicates = [];
  
    allPartyUuids.forEach(uuid => {
      uuidCount[uuid] = (uuidCount[uuid] || 0) + 1;
      if (uuidCount[uuid] === 2) {
        duplicates.push(uuid); // only push once when it becomes a duplicate
      }
    });
  
    // Step 3: Assert no duplicates
    expect(duplicates.length, `Duplicate partyUuid(s) found: ${duplicates.join(', ')}`).to.equal(0);
  
  });
}
